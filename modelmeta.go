package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/types"
	"os"
	"path/filepath"
	"reflect"
	"slices"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

const (
	exitErrorCode = 1

	flagType = "type"
	flagDir  = "dir"

	mode           = packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo
	packagePattern = "."

	tpl = `// Code generated by modelmeta-gen. DO NOT EDIT.
// Source: {{.SourcePath}}

package {{.Package}}
{{if .HasDefaultColumns}}
const {{.Type}}DefaultColumns = "{{.DefaultColumns}}"
{{end}}
var {{.Type}}Meta = meta.NewMeta([]meta.FieldMeta{
{{range .Fields}}	{Field: "{{.Field}}", Column: "{{.Column}}", Property: "{{.Property}}"},
{{end}}})
{{if .HasDefaultColumns}}
func (m {{.Type}}) Fields() (entity *{{.Type}}, fields []any) {
	return &m, []any{
{{range .Fields}}{{if .IsDefaultColumn}}		&m.{{.Field}},
{{end}}{{end}}	}
}
{{end}}
func (m *{{.Type}}) ColumnToProperty(column string) string {
	if fieldMeta, ok := {{.Type}}Meta.ByColumn(column); ok {
		return fieldMeta.Property
	}
	return ""
}
{{range .FieldsEndsWithAt}}
func (m *{{$.Type}}) {{.}}TZ() nullable.Time {
  return datetime.InTimeZone(m.{{.}}, m.{{.}}UTCOffset)
}
{{end}}{{range .NullableFieldsEndsWithAt}}
func (m *{{$.Type}}) {{.}}TZ() nullable.Time {
  return datetime.InTimeZone(m.{{.}}.Time, m.{{.}}UTCOffset)
}
{{end}}`

	fileSuffix                           = "_meta_gen.go"
	modeRWOwnerRGroupROthers os.FileMode = 0o644
)

var (
	ErrType = errors.New("-type must be provided")

	ErrNoPackages = errors.New("no packages loaded")

	typeName *string
	dir      *string
)

func main() {
	if err := run(); err != nil {
		_, _ = fmt.Fprintln(os.Stderr, err)
		os.Exit(exitErrorCode)
	}
}

func run() error {
	if err := setupFlags(); err != nil {
		return err
	}
	return newGenerator(*typeName, *dir).handle()
}

func setupFlags() error {
	typeName = flag.String(flagType, "", "type name.")
	dir = flag.String(flagDir, "", "package directory. The current directory by default.")

	usage := flag.Usage
	flag.Usage = func() {
		_, _ = fmt.Print(`Generates metadata and helpers for models.

`)
		usage()
	}

	flag.Parse()
	return validateFlags()
}

func validateFlags() error {
	if *typeName == "" {
		return ErrType
	}
	return nil
}

type structData struct {
	fields           []structField
	fieldNames       []string
	defaultColumns   []string
	tzFields         []string
	nullableTZFields []string
}

type structField struct {
	field           string
	typeName        string
	column          string
	isDefaultColumn bool
	property        string
}

type generator struct {
	typeName   string
	dir        string
	pkg        *packages.Package
	sourcePath string
	structType *types.Struct
	structData structData
	output     []byte
}

func (g *generator) handle() error {
	if err := g.loadPackage(); err != nil {
		return err
	}

	if err := g.readStruct(); err != nil {
		return err
	}

	g.readStructData()
	if g.structData.fields == nil {
		return nil
	}

	if err := g.generate(); err != nil {
		return err
	}
	return g.write()
}

func (g *generator) loadPackage() error {
	config := &packages.Config{
		Mode: mode,
		Dir:  g.dir,
	}
	pkgs, err := packages.Load(config, packagePattern)
	if err != nil {
		return fmt.Errorf("cannot load package: %w", err)
	}
	if len(pkgs) == 0 {
		return ErrNoPackages
	}

	g.pkg = pkgs[0]
	return nil
}

func (g *generator) readStruct() error {
	object := g.pkg.Types.Scope().Lookup(g.typeName)
	if object == nil {
		return fmt.Errorf("cannot find type %q", g.typeName)
	}

	g.readSourcePath(object)
	var ok bool
	if g.structType, ok = object.Type().Underlying().(*types.Struct); !ok {
		return fmt.Errorf("cannot find struct %q", g.typeName)
	}
	return nil
}

func (g *generator) readSourcePath(object types.Object) {
	path := g.pkg.Fset.File(object.Pos()).Name()
	filename := filepath.Base(path)
	g.sourcePath = filepath.Join(g.pkg.PkgPath, filename)
}

func (g *generator) readStructData() {
	g.readStructFields()
	g.readStructTZFields()
}

func (g *generator) readStructFields() {
	for i := range g.structType.NumFields() {
		field := g.structType.Field(i)
		fieldName := field.Name()
		tag := g.structType.Tag(i)
		tagValues := parseTag(tag, "db", "api")
		db := tagValues[0]
		column := db[0]
		isDefaultColumn := column != ""
		if len(db) > 1 && db[1] == "skipdefault" {
			isDefaultColumn = false
		}
		api := tagValues[1]
		property := api[0]
		g.structData.fields = append(g.structData.fields, structField{
			field:           fieldName,
			typeName:        field.Type().String(),
			column:          column,
			isDefaultColumn: isDefaultColumn,
			property:        property,
		})
		g.structData.fieldNames = append(g.structData.fieldNames, fieldName)
		if isDefaultColumn {
			g.structData.defaultColumns = append(g.structData.defaultColumns, column)
		}
	}
}

func parseTag(tag string, keys ...string) [][]string {
	values := make([][]string, len(keys))
	parts := reflect.StructTag(tag)
	for i, key := range keys {
		if value, ok := parts.Lookup(key); ok {
			values[i] = strings.Split(value, ",")
		} else {
			values[i] = []string{""}
		}
	}
	return values
}

func (g *generator) readStructTZFields() {
	for _, field := range g.structData.fields {
		if strings.HasSuffix(field.field, "At") && slices.Contains(g.structData.fieldNames, field.field+"UTCOffset") {
			switch {
			case field.typeName == "time.Time":
				g.structData.tzFields = append(g.structData.tzFields, field.field)
			case strings.HasSuffix(field.typeName, "nullable.Time"):
				g.structData.nullableTZFields = append(g.structData.nullableTZFields, field.field)
			}
		}
	}
}

func (g *generator) generate() error {
	var err error
	g.output, err = applyTemplate(g.typeName, tpl, g.templateData())
	if err != nil {
		return fmt.Errorf("cannot apply template: %w", err)
	}
	return g.formatAndAddImport()
}

func applyTemplate(name, tpl string, data any) ([]byte, error) {
	t, err := template.New(name).Parse(tpl)
	if err != nil {
		return nil, err
	}

	buf := new(bytes.Buffer)
	if err := t.Execute(buf, data); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (g *generator) templateData() any {
	type dataField struct {
		Field           string
		Column          string
		IsDefaultColumn bool
		Property        string
	}

	type data struct {
		Type                     string
		SourcePath               string
		Package                  string
		HasDefaultColumns        bool
		DefaultColumns           string
		Fields                   []dataField
		FieldsEndsWithAt         []string
		NullableFieldsEndsWithAt []string
	}

	d := data{
		Type:                     g.typeName,
		SourcePath:               g.sourcePath,
		Package:                  g.pkg.Name,
		HasDefaultColumns:        g.structData.defaultColumns != nil,
		DefaultColumns:           strings.Join(g.structData.defaultColumns, ", "),
		FieldsEndsWithAt:         g.structData.tzFields,
		NullableFieldsEndsWithAt: g.structData.nullableTZFields,
	}
	for _, field := range g.structData.fields {
		d.Fields = append(d.Fields, dataField{
			Field:           field.field,
			Column:          field.column,
			IsDefaultColumn: field.isDefaultColumn,
			Property:        field.property,
		})
	}
	return d
}

func (g *generator) formatAndAddImport() error {
	var err error
	g.output, err = imports.Process("", g.output, nil)
	if err != nil {
		return fmt.Errorf("goimports error: %w", err)
	}
	return nil
}

func (g *generator) write() error {
	filename := strings.ToLower(g.typeName) + fileSuffix
	path := filepath.Join(g.pkg.Dir, filename)
	if err := os.WriteFile(path, g.output, modeRWOwnerRGroupROthers); err != nil {
		return fmt.Errorf("cannot write to file %q: %w", path, err)
	}
	return nil
}

func newGenerator(typeName, dir string) *generator {
	return &generator{
		typeName: typeName,
		dir:      dir,
	}
}
